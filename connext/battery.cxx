/* Connext */
//#include <dds/pub/ddspub.hpp>
#include <dds/dds.hpp>
// Or simply include <dds/dds.hpp> 
#include "cow.hpp"

/* OpenSplice */
//#include "generated/cow_DCPS.hpp"

//#include "unistd.h"
#include <ctime>
#include "math.h"

#define ID "battery1"

bool isSv = false;
float voltage = 480.0;
float current = 0.0;
float watts = 250000.0;
float vars = 0.0;
float frequency = 60.0;
bool isOpen = true;
float stateOfCharge = 10.0;

int main(int argc, char *arv[])
{
    dds::domain::DomainParticipant dp( 0 );

    dds::topic::qos::TopicQos qos = 
        dp.default_topic_qos()
        << dds::core::policy::Durability::Transient()
        << dds::core::policy::Reliability::Reliable();

    dds::topic::Topic<cow::Reading> batteryTopic( dp, "Battery", qos );
    //dds::pub::DataWriter<cow::Reading> pvw(dp, batteryTopic, batteryTopic.qos());
    dds::pub::DataWriter<cow::Reading> pvw(dds::pub::Publisher(dp), batteryTopic/*, batteryTopic.qos()*/);

    dds::topic::Topic<cow::SetWatts> swTopic( dp, "SetWatts", qos );	
    //dds::sub::DataReader<cow::SetWatts> swr( dp, swTopic, swTopic.qos() );
    dds::sub::DataReader<cow::SetWatts> swr(dds::sub::Subscriber(dp), swTopic/*, swTopic.qos()*/);
    dds::sub::cond::ReadCondition swrc(swr, dds::sub::status::DataState(), [&swr](/*dds::sub::DataReader<cow::SetWatts>& dr*/){
        dds::sub::LoanedSamples<cow::SetWatts> samples = swr.take();
        dds::sub::LoanedSamples<cow::SetWatts>::const_iterator reading = samples.begin();

        if (reading->info()->valid()) {
            dds::core::string name = reading->data().name();
            std::cout << "Received SetWatts message for " << name;
            if (name == ID) {
                isSv = reading->data().watts() >= 0.0;
                std::cout << "[battery] new watts: " << watts << std::endl;
            }
        }
    }
    );

    dds::topic::Topic<cow::OpenClose> ocTopic( dp, "OpenClose", qos );	
    //dds::sub::DataReader<cow::OpenClose> ocr( dp, ocTopic, ocTopic.qos() );
    dds::sub::DataReader<cow::OpenClose> ocr(dds::sub::Subscriber(dp), ocTopic/*, ocTopic.qos()*/);
    dds::sub::cond::ReadCondition ocrc(ocr, dds::sub::status::DataState(), [&ocr]() {
        dds::sub::LoanedSamples<cow::OpenClose> samples = ocr.take();
        /* typename */ dds::sub::LoanedSamples<cow::OpenClose>::const_iterator reading = samples.begin();

        if (reading->info()->valid()) {
            dds::core::string name = reading->data().name();
            std::cout << "Received OpenClose message for " << name;
            if (reading->data().name() == ID){
                isOpen = reading->data().isOpen();
                std::cout << "[battery] new isOpen: " << isOpen << std::endl;
            }
           
        }   /* else {
            cow::OpenClose instance;
            dds::core::InstanceHandle handle = reading->info().instance_handle();
            ocr.key_value(instance, handle);
            std::string name(instance.name());
            std::cout << "Writer of OpenClose left for " << name;
        }    */
    });

    dds::core::cond::WaitSet ws;
    ws += swrc;
    ws += ocrc;

    while( true ) {
        try {
            ws.dispatch( dds::core::Duration(1, 0) );
        } catch (dds::core::TimeoutError e1) {

        }

        //THIS IS AN OVER-SIMPLIFICATION OF BATTERY BEHAVIOR
        // we are assuming SV -> always discharge and SC -> always charge
        if( isOpen ){
            pvw << cow::Reading( ID, 0, 0, 0, 0, 0, std::time(0), isOpen, stateOfCharge );
        }
        else{
            watts = 250000.0 * stateOfCharge / 100;
            current = watts / sqrt(3) / voltage;
            if( isSv ){
                stateOfCharge -= 1.0;
                if (stateOfCharge < 0)
                    stateOfCharge = 0.0;
            }
            else{
                watts *= -1.0;
                stateOfCharge += 1.0;
                if (stateOfCharge > 100.0)
                    stateOfCharge = 100.0;
            }
            pvw << cow::Reading( ID, voltage, current, watts, vars, frequency, std::time(0), isOpen, stateOfCharge );
        }
    };

    return 0;
}

#if 0
/* cow_subscriber.cxx

A subscription example

This file is derived from code automatically generated by the rtiddsgen 
command:

rtiddsgen -language C++11 -example <arch> cow.idl

Example subscription of type cow::SvSc automatically generated by 
'rtiddsgen'. To test them, follow these steps:

(1) Compile this file and the example publication.

(2) Start the subscription on the same domain used for RTI Data Distribution
Service  with the command
objs/<arch>/cow_subscriber <domain_id> <sample_count>

(3) Start the publication on the same domain used for RTI Data Distribution
Service with the command
objs/<arch>/cow_publisher <domain_id> <sample_count>

(4) [Optional] Specify the list of discovery initial peers and 
multicast receive addresses via an environment variable or a file 
(in the current working directory) called NDDS_DISCOVERY_PEERS. 

You can run any number of publishers and subscribers programs, and can 
add and remove them dynamically from the domain.

Example:

To run the example application on domain <domain_id>:

On UNIX systems: 

objs/<arch>/cow_publisher <domain_id> 
objs/<arch>/cow_subscriber <domain_id> 

On Windows systems:

objs\<arch>\cow_publisher <domain_id>  
objs\<arch>\cow_subscriber <domain_id>   

*/
#include <algorithm>
#include <iostream>

#include <dds/sub/ddssub.hpp>
#include <dds/core/ddscore.hpp>
// Or simply include <dds/dds.hpp> 

#include "cow.hpp"

void subscriber_main(int domain_id, int sample_count)
{
    // Create a DomainParticipant with default Qos
    dds::domain::DomainParticipant participant(domain_id);

    // Create a Topic -- and automatically register the type
    dds::topic::Topic<cow::SvSc> topic(participant, "Example cow::SvSc");

    // Create a DataReader with default Qos (Subscriber created in-line)
    dds::sub::DataReader<cow::SvSc> reader(dds::sub::Subscriber(participant), topic);

    // Create a ReadCondition for any data on this reader and associate a handler
    int count = 0;
    dds::sub::cond::ReadCondition read_condition(
        reader,
        dds::sub::status::DataState::any(),
        [&reader, &count]()
    {
        // Take all samples
        dds::sub::LoanedSamples<cow::SvSc> samples = reader.take();
        for (auto sample : samples){
            if (sample.info().valid()){
                count++;
                std::cout << sample.data() << std::endl; 
            }   
        }

    } // The LoanedSamples destructor returns the loan
    );

    // Create a WaitSet and attach the ReadCondition
    dds::core::cond::WaitSet waitset;
    waitset += read_condition;

    while (count < sample_count || sample_count == 0) {
        // Dispatch will call the handlers associated to the WaitSet conditions
        // when they activate
        std::cout << "cow::SvSc subscriber sleeping for 4 sec..." << std::endl;
        waitset.dispatch(dds::core::Duration(4)); // Wait up to 4s each time
    }
}

int main(int argc, char *argv[])
{

    int domain_id = 0;
    int sample_count = 0; // infinite loop

    if (argc >= 2) {
        domain_id = atoi(argv[1]);
    }
    if (argc >= 3) {
        sample_count = atoi(argv[2]);
    }

    // To turn on additional logging, include <rti/config/Logger.hpp> and
    // uncomment the following line:
    // rti::config::Logger::instance().verbosity(rti::config::Verbosity::STATUS_ALL);

    try {
        subscriber_main(domain_id, sample_count);
    } catch (const std::exception& ex) {
        // This will catch DDS exceptions
        std::cerr << "Exception in subscriber_main(): " << ex.what() << std::endl;
        return -1;
    }

    // RTI Connext provides a finalize_participant_factory() method
    // if you want to release memory used by the participant factory singleton.
    // Uncomment the following line to release the singleton:
    //
    // dds::domain::DomainParticipant::finalize_participant_factory();

    return 0;
}
#endif
